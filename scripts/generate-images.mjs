import fs from 'node:fs/promises'
import path from 'node:path'

const imagesDir = path.resolve('src/assets/images')
const outFile = path.resolve('src/shared/assets/images/generated.ts')
const reportFile = path.resolve('scripts/.cache/images-report.json')
const exts = new Set(['.svg', '.png'])
const aliasPrefix = '@/assets/images'
const imagesAliasTarget = path.resolve('src/assets/images')
if (imagesDir !== imagesAliasTarget) {
  console.warn(
    'Warning: imagesDir does not match @ alias target for assets. Imports may be incorrect.',
  )
}

/** 지정한 디렉터리 하위 이미지 파일을 재귀적으로 수집 */
async function walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true })
  const files = []
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name)
    if (entry.isDirectory()) {
      files.push(...(await walk(fullPath)))
    } else if (entry.isFile() && exts.has(path.extname(entry.name))) {
      files.push(fullPath)
    }
  }
  return files
}

/** import 경로 일관성을 위한 POSIX 구분자 정규화 */
function toPosix(filePath) {
  return filePath.split(path.sep).join('/')
}

/** 생성된 import 이름의 JS 식별자 안전성 확보 */
function sanitizeIdentifier(value) {
  const cleaned = value.replace(/[^a-zA-Z0-9_]/g, '_')
  return cleaned.match(/^[0-9]/) ? `_${cleaned}` : cleaned
}

/** 파일명을 camelCase 키로 변환 */
function toCamelCase(value) {
  return value
    .replace(/[-_\s]+(.)?/g, (_, chr) => (chr ? chr.toUpperCase() : ''))
    .replace(/^[A-Z]/, (chr) => chr.toLowerCase())
}

/** 실행마다 동일한 결과를 위한 정렬 */
const files = (await walk(imagesDir)).sort()

function parseGenerated(content) {
  const importMap = new Map()
  const importRegex = /^import (\w+) from '([^']+)'/gm
  let match
  while ((match = importRegex.exec(content))) {
    importMap.set(match[1], match[2])
  }

  const keyMap = new Map()
  const groupRegex = /^\s{2}"([^"]+)": \{$/gm
  let groupMatch
  while ((groupMatch = groupRegex.exec(content))) {
    const group = groupMatch[1]
    const start = groupMatch.index
    const block = content.slice(start, content.indexOf('  },', start) + 3)
    const itemRegex = /^\s{4}"([^"]+)": (\w+),$/gm
    let itemMatch
    while ((itemMatch = itemRegex.exec(block))) {
      const name = itemMatch[1]
      const importId = itemMatch[2]
      const relPath = importMap.get(importId)
      if (!relPath) continue
      keyMap.set(`${group}.${name}`, relPath)
    }
  }

  return keyMap
}

/** 생성된 import 구문과 그룹별 아이콘 항목 추적 */
const imports = []
const groups = new Map()

/** 파일 경로에서 import 목록과 그룹/이름 인덱스 구성 */
for (const filePath of files) {
  const rel = path.relative(imagesDir, filePath)
  const relPosix = toPosix(rel)
  const parts = relPosix.split('/')
  const group = parts[0] || 'root'
  const nameWithExt = parts.slice(1).join('/') || parts[0]
  const name = nameWithExt.replace(/\.[^.]+$/, '')
  const key = toCamelCase(name)
  const importId = sanitizeIdentifier(`img_${group}_${name}`)

  imports.push(`import ${importId} from '${aliasPrefix}/${relPosix}'`)

  if (!groups.has(group)) groups.set(group, [])
  groups.get(group).push({ name: key, importId })
}

let previousMap = new Map()
try {
  const prev = await fs.readFile(outFile, 'utf8')
  previousMap = parseGenerated(prev)
} catch {
  previousMap = new Map()
}

/** 생성될 TypeScript 모듈 내용 구성 */
let output = ''
output +=
  '// This file is auto-generated by scripts/generate-images.mjs.\n' +
  '// Do not edit this file manually.\n\n'

if (imports.length) {
  output += `${imports.join('\n')}\n\n`
}

output += 'export const icons = {\n'
for (const [group, items] of groups) {
  output += `  ${JSON.stringify(group)}: {\n`
  for (const item of items) {
    output += `    ${JSON.stringify(item.name)}: ${item.importId},\n`
  }
  output += '  },\n'
}
output += '} as const\n\n'

output += 'export type IconGroups = typeof icons\n'
output += 'export type IconGroup = keyof IconGroups\n'
output += 'export type IconName<G extends IconGroup> = keyof IconGroups[G]\n'

const nextMap = new Map()
for (const [group, items] of groups) {
  for (const item of items) {
    const relPath = imports.find((line) =>
      line.includes(` ${item.importId} from `),
    )
    if (!relPath) continue
    const match = relPath.match(/'([^']+)'/)
    if (!match) continue
    const key = `${group}.${item.name}`
    nextMap.set(key, match[1])
  }
}

const prevKeys = new Set(previousMap.keys())
const nextKeys = new Set(nextMap.keys())
const added = [...nextKeys].filter((key) => !prevKeys.has(key))
const removed = [...prevKeys].filter((key) => !nextKeys.has(key))

const prevPathMap = new Map()
for (const [key, relPath] of previousMap) prevPathMap.set(relPath, key)
const nextPathMap = new Map()
for (const [key, relPath] of nextMap) nextPathMap.set(relPath, key)

const renamed = []
for (const [relPath, prevKey] of prevPathMap) {
  const nextKey = nextPathMap.get(relPath)
  if (nextKey && nextKey !== prevKey) {
    renamed.push({ from: prevKey, to: nextKey, path: relPath })
  }
}

await fs.mkdir(path.dirname(outFile), { recursive: true })
await fs.writeFile(outFile, output, 'utf8')

await fs.mkdir(path.dirname(reportFile), { recursive: true })
await fs.writeFile(
  reportFile,
  JSON.stringify({ added, removed, renamed }, null, 2),
  'utf8',
)

const summary = [
  `Generated ${path.relative(process.cwd(), outFile)}`,
  `Added: ${added.length}, Removed: ${removed.length}, Renamed: ${renamed.length}`,
]
console.log(summary.join('\n'))
